eval("// Hack for  https://github.com/joliss/broccoli-es6-concatenator/issues/9\n//# sourceURL=_loader.js");
eval("define(\"quick-hunt/tests/helpers/resolver\", \n  [\"ember/resolver\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var Resolver = __dependency1__[\"default\"];\n\n    var resolver = Resolver.create();\n\n    resolver.namespace = {\n      modulePrefix: \'quick-hunt\'\n    };\n\n    __exports__[\"default\"] = resolver;\n  });//# sourceURL=quick-hunt/tests/helpers/resolver.js");
eval("define(\"quick-hunt/tests/helpers/start-app\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var Application = require(\'quick-hunt/app\')[\'default\'];\n    var Router = require(\'quick-hunt/router\')[\'default\'];\n\n    function startApp(attrs) {\n      var App;\n\n      var attributes = Ember.merge({\n        // useful Test defaults\n        rootElement: \'#ember-testing\',\n        LOG_ACTIVE_GENERATION:false,\n        LOG_VIEW_LOOKUPS: false\n      }, attrs); // but you can override;\n\n      Router.reopen({\n        location: \'none\'\n      });\n\n      Ember.run(function(){\n        App = Application.create(attributes);\n        App.setupForTesting();\n        App.injectTestHelpers();\n      });\n\n      App.reset(); // this shouldn\'t be needed, i want to be able to \"start an app at a specific URL\"\n\n      return App;\n    }\n\n    __exports__[\"default\"] = startApp;\n  });//# sourceURL=quick-hunt/tests/helpers/start-app.js");
eval("define(\"quick-hunt/tests/test-helper\", \n  [\"quick-hunt/tests/helpers/resolver\"],\n  function(__dependency1__) {\n    \"use strict\";\n    document.write(\'<div id=\"ember-testing-container\"><div id=\"ember-testing\"></div></div>\');\n\n    Ember.testing = true;\n\n    var resolver = __dependency1__[\"default\"];\n    require(\'ember-qunit\').setResolver(resolver);\n\n    function exists(selector) {\n      return !!find(selector).length;\n    }\n\n    function getAssertionMessage(actual, expected, message) {\n      return message || QUnit.jsDump.parse(expected) + \" expected but was \" + QUnit.jsDump.parse(actual);\n    }\n\n    function equal(actual, expected, message) {\n      message = getAssertionMessage(actual, expected, message);\n      QUnit.equal.call(this, actual, expected, message);\n    }\n\n    function strictEqual(actual, expected, message) {\n      message = getAssertionMessage(actual, expected, message);\n      QUnit.strictEqual.call(this, actual, expected, message);\n    }\n\n    window.exists = exists;\n    window.equal = equal;\n    window.strictEqual = strictEqual;\n  });//# sourceURL=quick-hunt/tests/test-helper.js");
eval("define(\"quick-hunt/tests/test-loader\", \n  [],\n  function() {\n    \"use strict\";\n    // TODO: load based on params\n    Ember.keys(requirejs._eak_seen).filter(function(key) {\n      return (/\\-test/).test(key);\n    }).forEach(function(moduleName) {\n      require(moduleName, null, null, true);\n    });\n  });//# sourceURL=quick-hunt/tests/test-loader.js");
eval("/**\n * QUnit v1.12.0 - A JavaScript Unit Testing Framework\n *\n * http://qunitjs.com\n *\n * Copyright 2013 jQuery Foundation and other contributors\n * Released under the MIT license.\n * https://jquery.org/license/\n */\n\n(function( window ) {\n\nvar QUnit,\n	assert,\n	config,\n	onErrorFnPrev,\n	testId = 0,\n	fileName = (sourceFromStacktrace( 0 ) || \"\" ).replace(/(:\\d+)+\\)?/, \"\").replace(/.+\\//, \"\"),\n	toString = Object.prototype.toString,\n	hasOwn = Object.prototype.hasOwnProperty,\n	// Keep a local reference to Date (GH-283)\n	Date = window.Date,\n	setTimeout = window.setTimeout,\n	defined = {\n		setTimeout: typeof window.setTimeout !== \"undefined\",\n		sessionStorage: (function() {\n			var x = \"qunit-test-string\";\n			try {\n				sessionStorage.setItem( x, x );\n				sessionStorage.removeItem( x );\n				return true;\n			} catch( e ) {\n				return false;\n			}\n		}())\n	},\n	/**\n	 * Provides a normalized error string, correcting an issue\n	 * with IE 7 (and prior) where Error.prototype.toString is\n	 * not properly implemented\n	 *\n	 * Based on http://es5.github.com/#x15.11.4.4\n	 *\n	 * @param {String|Error} error\n	 * @return {String} error message\n	 */\n	errorString = function( error ) {\n		var name, message,\n			errorString = error.toString();\n		if ( errorString.substring( 0, 7 ) === \"[object\" ) {\n			name = error.name ? error.name.toString() : \"Error\";\n			message = error.message ? error.message.toString() : \"\";\n			if ( name && message ) {\n				return name + \": \" + message;\n			} else if ( name ) {\n				return name;\n			} else if ( message ) {\n				return message;\n			} else {\n				return \"Error\";\n			}\n		} else {\n			return errorString;\n		}\n	},\n	/**\n	 * Makes a clone of an object using only Array or Object as base,\n	 * and copies over the own enumerable properties.\n	 *\n	 * @param {Object} obj\n	 * @return {Object} New object with only the own properties (recursively).\n	 */\n	objectValues = function( obj ) {\n		// Grunt 0.3.x uses an older version of jshint that still has jshint/jshint#392.\n		/*jshint newcap: false */\n		var key, val,\n			vals = QUnit.is( \"array\", obj ) ? [] : {};\n		for ( key in obj ) {\n			if ( hasOwn.call( obj, key ) ) {\n				val = obj[key];\n				vals[key] = val === Object(val) ? objectValues(val) : val;\n			}\n		}\n		return vals;\n	};\n\nfunction Test( settings ) {\n	extend( this, settings );\n	this.assertions = [];\n	this.testNumber = ++Test.count;\n}\n\nTest.count = 0;\n\nTest.prototype = {\n	init: function() {\n		var a, b, li,\n			tests = id( \"qunit-tests\" );\n\n		if ( tests ) {\n			b = document.createElement( \"strong\" );\n			b.innerHTML = this.nameHtml;\n\n			// `a` initialized at top of scope\n			a = document.createElement( \"a\" );\n			a.innerHTML = \"Rerun\";\n			a.href = QUnit.url({ testNumber: this.testNumber });\n\n			li = document.createElement( \"li\" );\n			li.appendChild( b );\n			li.appendChild( a );\n			li.className = \"running\";\n			li.id = this.id = \"qunit-test-output\" + testId++;\n\n			tests.appendChild( li );\n		}\n	},\n	setup: function() {\n		if (\n			// Emit moduleStart when we\'re switching from one module to another\n			this.module !== config.previousModule ||\n				// They could be equal (both undefined) but if the previousModule property doesn\'t\n				// yet exist it means this is the first test in a suite that isn\'t wrapped in a\n				// module, in which case we\'ll just emit a moduleStart event for \'undefined\'.\n				// Without this, reporters can get testStart before moduleStart  which is a problem.\n				!hasOwn.call( config, \"previousModule\" )\n		) {\n			if ( hasOwn.call( config, \"previousModule\" ) ) {\n				runLoggingCallbacks( \"moduleDone\", QUnit, {\n					name: config.previousModule,\n					failed: config.moduleStats.bad,\n					passed: config.moduleStats.all - config.moduleStats.bad,\n					total: config.moduleStats.all\n				});\n			}\n			config.previousModule = this.module;\n			config.moduleStats = { all: 0, bad: 0 };\n			runLoggingCallbacks( \"moduleStart\", QUnit, {\n				name: this.module\n			});\n		}\n\n		config.current = this;\n\n		this.testEnvironment = extend({\n			setup: function() {},\n			teardown: function() {}\n		}, this.moduleTestEnvironment );\n\n		this.started = +new Date();\n		runLoggingCallbacks( \"testStart\", QUnit, {\n			name: this.testName,\n			module: this.module\n		});\n\n		/*jshint camelcase:false */\n\n\n		/**\n		 * Expose the current test environment.\n		 *\n		 * @deprecated since 1.12.0: Use QUnit.config.current.testEnvironment instead.\n		 */\n		QUnit.current_testEnvironment = this.testEnvironment;\n\n		/*jshint camelcase:true */\n\n		if ( !config.pollution ) {\n			saveGlobal();\n		}\n		if ( config.notrycatch ) {\n			this.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n			return;\n		}\n		try {\n			this.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );\n		} catch( e ) {\n			QUnit.pushFailure( \"Setup failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n		}\n	},\n	run: function() {\n		config.current = this;\n\n		var running = id( \"qunit-testresult\" );\n\n		if ( running ) {\n			running.innerHTML = \"Running: <br/>\" + this.nameHtml;\n		}\n\n		if ( this.async ) {\n			QUnit.stop();\n		}\n\n		this.callbackStarted = +new Date();\n\n		if ( config.notrycatch ) {\n			this.callback.call( this.testEnvironment, QUnit.assert );\n			this.callbackRuntime = +new Date() - this.callbackStarted;\n			return;\n		}\n\n		try {\n			this.callback.call( this.testEnvironment, QUnit.assert );\n			this.callbackRuntime = +new Date() - this.callbackStarted;\n		} catch( e ) {\n			this.callbackRuntime = +new Date() - this.callbackStarted;\n\n			QUnit.pushFailure( \"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n			// else next test will carry the responsibility\n			saveGlobal();\n\n			// Restart the tests if they\'re blocking\n			if ( config.blocking ) {\n				QUnit.start();\n			}\n		}\n	},\n	teardown: function() {\n		config.current = this;\n		if ( config.notrycatch ) {\n			if ( typeof this.callbackRuntime === \"undefined\" ) {\n				this.callbackRuntime = +new Date() - this.callbackStarted;\n			}\n			this.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n			return;\n		} else {\n			try {\n				this.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );\n			} catch( e ) {\n				QUnit.pushFailure( \"Teardown failed on \" + this.testName + \": \" + ( e.message || e ), extractStacktrace( e, 1 ) );\n			}\n		}\n		checkPollution();\n	},\n	finish: function() {\n		config.current = this;\n		if ( config.requireExpects && this.expected === null ) {\n			QUnit.pushFailure( \"Expected number of assertions to be defined, but expect() was not called.\", this.stack );\n		} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n			QUnit.pushFailure( \"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack );\n		} else if ( this.expected === null && !this.assertions.length ) {\n			QUnit.pushFailure( \"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack );\n		}\n\n		var i, assertion, a, b, time, li, ol,\n			test = this,\n			good = 0,\n			bad = 0,\n			tests = id( \"qunit-tests\" );\n\n		this.runtime = +new Date() - this.started;\n		config.stats.all += this.assertions.length;\n		config.moduleStats.all += this.assertions.length;\n\n		if ( tests ) {\n			ol = document.createElement( \"ol\" );\n			ol.className = \"qunit-assert-list\";\n\n			for ( i = 0; i < this.assertions.length; i++ ) {\n				assertion = this.assertions[i];\n\n				li = document.createElement( \"li\" );\n				li.className = assertion.result ? \"pass\" : \"fail\";\n				li.innerHTML = assertion.message || ( assertion.result ? \"okay\" : \"failed\" );\n				ol.appendChild( li );\n\n				if ( assertion.result ) {\n					good++;\n				} else {\n					bad++;\n					config.stats.bad++;\n					config.moduleStats.bad++;\n				}\n			}\n\n			// store result when possible\n			if ( QUnit.config.reorder && defined.sessionStorage ) {\n				if ( bad ) {\n					sessionStorage.setItem( \"qunit-test-\" + this.module + \"-\" + this.testName, bad );\n				} else {\n					sessionStorage.removeItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n				}\n			}\n\n			if ( bad === 0 ) {\n				addClass( ol, \"qunit-collapsed\" );\n			}\n\n			// `b` initialized at top of scope\n			b = document.createElement( \"strong\" );\n			b.innerHTML = this.nameHtml + \" <b class=\'counts\'>(<b class=\'failed\'>\" + bad + \"</b>, <b class=\'passed\'>\" + good + \"</b>, \" + this.assertions.length + \")</b>\";\n\n			addEvent(b, \"click\", function() {\n				var next = b.parentNode.lastChild,\n					collapsed = hasClass( next, \"qunit-collapsed\" );\n				( collapsed ? removeClass : addClass )( next, \"qunit-collapsed\" );\n			});\n\n			addEvent(b, \"dblclick\", function( e ) {\n				var target = e && e.target ? e.target : window.event.srcElement;\n				if ( target.nodeName.toLowerCase() === \"span\" || target.nodeName.toLowerCase() === \"b\" ) {\n					target = target.parentNode;\n				}\n				if ( window.location && target.nodeName.toLowerCase() === \"strong\" ) {\n					window.location = QUnit.url({ testNumber: test.testNumber });\n				}\n			});\n\n			// `time` initialized at top of scope\n			time = document.createElement( \"span\" );\n			time.className = \"runtime\";\n			time.innerHTML = this.runtime + \" ms\";\n\n			// `li` initialized at top of scope\n			li = id( this.id );\n			li.className = bad ? \"fail\" : \"pass\";\n			li.removeChild( li.firstChild );\n			a = li.firstChild;\n			li.appendChild( b );\n			li.appendChild( a );\n			li.appendChild( time );\n			li.appendChild( ol );\n\n		} else {\n			for ( i = 0; i < this.assertions.length; i++ ) {\n				if ( !this.assertions[i].result ) {\n					bad++;\n					config.stats.bad++;\n					config.moduleStats.bad++;\n				}\n			}\n		}\n\n		runLoggingCallbacks( \"testDone\", QUnit, {\n			name: this.testName,\n			module: this.module,\n			failed: bad,\n			passed: this.assertions.length - bad,\n			total: this.assertions.length,\n			duration: this.runtime\n		});\n\n		QUnit.reset();\n\n		config.current = undefined;\n	},\n\n	queue: function() {\n		var bad,\n			test = this;\n\n		synchronize(function() {\n			test.init();\n		});\n		function run() {\n			// each of these can by async\n			synchronize(function() {\n				test.setup();\n			});\n			synchronize(function() {\n				test.run();\n			});\n			synchronize(function() {\n				test.teardown();\n			});\n			synchronize(function() {\n				test.finish();\n			});\n		}\n\n		// `bad` initialized at top of scope\n		// defer when previous test run passed, if storage is available\n		bad = QUnit.config.reorder && defined.sessionStorage &&\n						+sessionStorage.getItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\n\n		if ( bad ) {\n			run();\n		} else {\n			synchronize( run, true );\n		}\n	}\n};\n\n// Root QUnit object.\n// `QUnit` initialized at top of scope\nQUnit = {\n\n	// call on start of module test to prepend name to all tests\n	module: function( name, testEnvironment ) {\n		config.currentModule = name;\n		config.currentModuleTestEnvironment = testEnvironment;\n		config.modules[name] = true;\n	},\n\n	asyncTest: function( testName, expected, callback ) {\n		if ( arguments.length === 2 ) {\n			callback = expected;\n			expected = null;\n		}\n\n		QUnit.test( testName, expected, callback, true );\n	},\n\n	test: function( testName, expected, callback, async ) {\n		var test,\n			nameHtml = \"<span class=\'test-name\'>\" + escapeText( testName ) + \"</span>\";\n\n		if ( arguments.length === 2 ) {\n			callback = expected;\n			expected = null;\n		}\n\n		if ( config.currentModule ) {\n			nameHtml = \"<span class=\'module-name\'>\" + escapeText( config.currentModule ) + \"</span>: \" + nameHtml;\n		}\n\n		test = new Test({\n			nameHtml: nameHtml,\n			testName: testName,\n			expected: expected,\n			async: async,\n			callback: callback,\n			module: config.currentModule,\n			moduleTestEnvironment: config.currentModuleTestEnvironment,\n			stack: sourceFromStacktrace( 2 )\n		});\n\n		if ( !validTest( test ) ) {\n			return;\n		}\n\n		test.queue();\n	},\n\n	// Specify the number of expected assertions to guarantee that failed test (no assertions are run at all) don\'t slip through.\n	expect: function( asserts ) {\n		if (arguments.length === 1) {\n			config.current.expected = asserts;\n		} else {\n			return config.current.expected;\n		}\n	},\n\n	start: function( count ) {\n		// QUnit hasn\'t been initialized yet.\n		// Note: RequireJS (et al) may delay onLoad\n		if ( config.semaphore === undefined ) {\n			QUnit.begin(function() {\n				// This is triggered at the top of QUnit.load, push start() to the event loop, to allow QUnit.load to finish first\n				setTimeout(function() {\n					QUnit.start( count );\n				});\n			});\n			return;\n		}\n\n		config.semaphore -= count || 1;\n		// don\'t start until equal number of stop-calls\n		if ( config.semaphore > 0 ) {\n			return;\n		}\n		// ignore if start is called more often then stop\n		if ( config.semaphore < 0 ) {\n			config.semaphore = 0;\n			QUnit.pushFailure( \"Called start() while already started (QUnit.config.semaphore was 0 already)\", null, sourceFromStacktrace(2) );\n			return;\n		}\n		// A slight delay, to avoid any current callbacks\n		if ( defined.setTimeout ) {\n			setTimeout(function() {\n				if ( config.semaphore > 0 ) {\n					return;\n				}\n				if ( config.timeout ) {\n					clearTimeout( config.timeout );\n				}\n\n				config.blocking = false;\n				process( true );\n			}, 13);\n		} else {\n			config.blocking = false;\n			process( true );\n		}\n	},\n\n	stop: function( count ) {\n		config.semaphore += count || 1;\n		config.blocking = true;\n\n		if ( config.testTimeout && defined.setTimeout ) {\n			clearTimeout( config.timeout );\n			config.timeout = setTimeout(function() {\n				QUnit.ok( false, \"Test timed out\" );\n				config.semaphore = 1;\n				QUnit.start();\n			}, config.testTimeout );\n		}\n	}\n};\n\n// `assert` initialized at top of scope\n// Assert helpers\n// All of these must either call QUnit.push() or manually do:\n// - runLoggingCallbacks( \"log\", .. );\n// - config.current.assertions.push({ .. });\n// We attach it to the QUnit object *after* we expose the public API,\n// otherwise `assert` will become a global variable in browsers (#341).\nassert = {\n	/**\n	 * Asserts rough true-ish result.\n	 * @name ok\n	 * @function\n	 * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );\n	 */\n	ok: function( result, msg ) {\n		if ( !config.current ) {\n			throw new Error( \"ok() assertion outside test context, was \" + sourceFromStacktrace(2) );\n		}\n		result = !!result;\n		msg = msg || (result ? \"okay\" : \"failed\" );\n\n		var source,\n			details = {\n				module: config.current.module,\n				name: config.current.testName,\n				result: result,\n				message: msg\n			};\n\n		msg = \"<span class=\'test-message\'>\" + escapeText( msg ) + \"</span>\";\n\n		if ( !result ) {\n			source = sourceFromStacktrace( 2 );\n			if ( source ) {\n				details.source = source;\n				msg += \"<table><tr class=\'test-source\'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr></table>\";\n			}\n		}\n		runLoggingCallbacks( \"log\", QUnit, details );\n		config.current.assertions.push({\n			result: result,\n			message: msg\n		});\n	},\n\n	/**\n	 * Assert that the first two arguments are equal, with an optional message.\n	 * Prints out both actual and expected values.\n	 * @name equal\n	 * @function\n	 * @example equal( format( \"Received {0} bytes.\", 2), \"Received 2 bytes.\", \"format() replaces {0} with next argument\" );\n	 */\n	equal: function( actual, expected, message ) {\n		/*jshint eqeqeq:false */\n		QUnit.push( expected == actual, actual, expected, message );\n	},\n\n	/**\n	 * @name notEqual\n	 * @function\n	 */\n	notEqual: function( actual, expected, message ) {\n		/*jshint eqeqeq:false */\n		QUnit.push( expected != actual, actual, expected, message );\n	},\n\n	/**\n	 * @name propEqual\n	 * @function\n	 */\n	propEqual: function( actual, expected, message ) {\n		actual = objectValues(actual);\n		expected = objectValues(expected);\n		QUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n	},\n\n	/**\n	 * @name notPropEqual\n	 * @function\n	 */\n	notPropEqual: function( actual, expected, message ) {\n		actual = objectValues(actual);\n		expected = objectValues(expected);\n		QUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n	},\n\n	/**\n	 * @name deepEqual\n	 * @function\n	 */\n	deepEqual: function( actual, expected, message ) {\n		QUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\n	},\n\n	/**\n	 * @name notDeepEqual\n	 * @function\n	 */\n	notDeepEqual: function( actual, expected, message ) {\n		QUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\n	},\n\n	/**\n	 * @name strictEqual\n	 * @function\n	 */\n	strictEqual: function( actual, expected, message ) {\n		QUnit.push( expected === actual, actual, expected, message );\n	},\n\n	/**\n	 * @name notStrictEqual\n	 * @function\n	 */\n	notStrictEqual: function( actual, expected, message ) {\n		QUnit.push( expected !== actual, actual, expected, message );\n	},\n\n	\"throws\": function( block, expected, message ) {\n		var actual,\n			expectedOutput = expected,\n			ok = false;\n\n		// \'expected\' is optional\n		if ( typeof expected === \"string\" ) {\n			message = expected;\n			expected = null;\n		}\n\n		config.current.ignoreGlobalErrors = true;\n		try {\n			block.call( config.current.testEnvironment );\n		} catch (e) {\n			actual = e;\n		}\n		config.current.ignoreGlobalErrors = false;\n\n		if ( actual ) {\n			// we don\'t want to validate thrown error\n			if ( !expected ) {\n				ok = true;\n				expectedOutput = null;\n			// expected is a regexp\n			} else if ( QUnit.objectType( expected ) === \"regexp\" ) {\n				ok = expected.test( errorString( actual ) );\n			// expected is a constructor\n			} else if ( actual instanceof expected ) {\n				ok = true;\n			// expected is a validation function which returns true is validation passed\n			} else if ( expected.call( {}, actual ) === true ) {\n				expectedOutput = null;\n				ok = true;\n			}\n\n			QUnit.push( ok, actual, expectedOutput, message );\n		} else {\n			QUnit.pushFailure( message, null, \"No exception was thrown.\" );\n		}\n	}\n};\n\n/**\n * @deprecated since 1.8.0\n * Kept assertion helpers in root for backwards compatibility.\n */\nextend( QUnit, assert );\n\n/**\n * @deprecated since 1.9.0\n * Kept root \"raises()\" for backwards compatibility.\n * (Note that we don\'t introduce assert.raises).\n */\nQUnit.raises = assert[ \"throws\" ];\n\n/**\n * @deprecated since 1.0.0, replaced with error pushes since 1.3.0\n * Kept to avoid TypeErrors for undefined methods.\n */\nQUnit.equals = function() {\n	QUnit.push( false, false, false, \"QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead\" );\n};\nQUnit.same = function() {\n	QUnit.push( false, false, false, \"QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead\" );\n};\n\n// We want access to the constructor\'s prototype\n(function() {\n	function F() {}\n	F.prototype = QUnit;\n	QUnit = new F();\n	// Make F QUnit\'s constructor so that we can add to the prototype later\n	QUnit.constructor = F;\n}());\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nconfig = {\n	// The queue of tests to run\n	queue: [],\n\n	// block until document ready\n	blocking: true,\n\n	// when enabled, show only failing tests\n	// gets persisted through sessionStorage and can be changed in UI via checkbox\n	hidepassed: false,\n\n	// by default, run previously failed tests first\n	// very useful in combination with \"Hide passed tests\" checked\n	reorder: true,\n\n	// by default, modify document.title when suite is done\n	altertitle: true,\n\n	// when enabled, all tests must call expect()\n	requireExpects: false,\n\n	// add checkboxes that are persisted in the query-string\n	// when enabled, the id is set to `true` as a `QUnit.config` property\n	urlConfig: [\n		{\n			id: \"noglobals\",\n			label: \"Check for Globals\",\n			tooltip: \"Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings.\"\n		},\n		{\n			id: \"notrycatch\",\n			label: \"No try-catch\",\n			tooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\n		}\n	],\n\n	// Set of all modules.\n	modules: {},\n\n	// logging callback queues\n	begin: [],\n	done: [],\n	log: [],\n	testStart: [],\n	testDone: [],\n	moduleStart: [],\n	moduleDone: []\n};\n\n// Export global variables, unless an \'exports\' object exists,\n// in that case we assume we\'re in CommonJS (dealt with on the bottom of the script)\nif ( typeof exports === \"undefined\" ) {\n	extend( window, QUnit.constructor.prototype );\n\n	// Expose QUnit object\n	window.QUnit = QUnit;\n}\n\n// Initialize more QUnit.config and QUnit.urlParams\n(function() {\n	var i,\n		location = window.location || { search: \"\", protocol: \"file:\" },\n		params = location.search.slice( 1 ).split( \"&\" ),\n		length = params.length,\n		urlParams = {},\n		current;\n\n	if ( params[ 0 ] ) {\n		for ( i = 0; i < length; i++ ) {\n			current = params[ i ].split( \"=\" );\n			current[ 0 ] = decodeURIComponent( current[ 0 ] );\n			// allow just a key to turn on a flag, e.g., test.html?noglobals\n			current[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n			urlParams[ current[ 0 ] ] = current[ 1 ];\n		}\n	}\n\n	QUnit.urlParams = urlParams;\n\n	// String search anywhere in moduleName+testName\n	config.filter = urlParams.filter;\n\n	// Exact match of the module name\n	config.module = urlParams.module;\n\n	config.testNumber = parseInt( urlParams.testNumber, 10 ) || null;\n\n	// Figure out if we\'re running the tests from a server or not\n	QUnit.isLocal = location.protocol === \"file:\";\n}());\n\n// Extend QUnit object,\n// these after set here because they should not be exposed as global functions\nextend( QUnit, {\n	assert: assert,\n\n	config: config,\n\n	// Initialize the configuration options\n	init: function() {\n		extend( config, {\n			stats: { all: 0, bad: 0 },\n			moduleStats: { all: 0, bad: 0 },\n			started: +new Date(),\n			updateRate: 1000,\n			blocking: false,\n			autostart: true,\n			autorun: false,\n			filter: \"\",\n			queue: [],\n			semaphore: 1\n		});\n\n		var tests, banner, result,\n			qunit = id( \"qunit\" );\n\n		if ( qunit ) {\n			qunit.innerHTML =\n				\"<h1 id=\'qunit-header\'>\" + escapeText( document.title ) + \"</h1>\" +\n				\"<h2 id=\'qunit-banner\'></h2>\" +\n				\"<div id=\'qunit-testrunner-toolbar\'></div>\" +\n				\"<h2 id=\'qunit-userAgent\'></h2>\" +\n				\"<ol id=\'qunit-tests\'></ol>\";\n		}\n\n		tests = id( \"qunit-tests\" );\n		banner = id( \"qunit-banner\" );\n		result = id( \"qunit-testresult\" );\n\n		if ( tests ) {\n			tests.innerHTML = \"\";\n		}\n\n		if ( banner ) {\n			banner.className = \"\";\n		}\n\n		if ( result ) {\n			result.parentNode.removeChild( result );\n		}\n\n		if ( tests ) {\n			result = document.createElement( \"p\" );\n			result.id = \"qunit-testresult\";\n			result.className = \"result\";\n			tests.parentNode.insertBefore( result, tests );\n			result.innerHTML = \"Running...<br/>&nbsp;\";\n		}\n	},\n\n	// Resets the test setup. Useful for tests that modify the DOM.\n	/*\n	DEPRECATED: Use multiple tests instead of resetting inside a test.\n	Use testStart or testDone for custom cleanup.\n	This method will throw an error in 2.0, and will be removed in 2.1\n	*/\n	reset: function() {\n		var fixture = id( \"qunit-fixture\" );\n		if ( fixture ) {\n			fixture.innerHTML = config.fixture;\n		}\n	},\n\n	// Trigger an event on an element.\n	// @example triggerEvent( document.body, \"click\" );\n	triggerEvent: function( elem, type, event ) {\n		if ( document.createEvent ) {\n			event = document.createEvent( \"MouseEvents\" );\n			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,\n				0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n			elem.dispatchEvent( event );\n		} else if ( elem.fireEvent ) {\n			elem.fireEvent( \"on\" + type );\n		}\n	},\n\n	// Safe object type checking\n	is: function( type, obj ) {\n		return QUnit.objectType( obj ) === type;\n	},\n\n	objectType: function( obj ) {\n		if ( typeof obj === \"undefined\" ) {\n				return \"undefined\";\n		// consider: typeof null === object\n		}\n		if ( obj === null ) {\n				return \"null\";\n		}\n\n		var match = toString.call( obj ).match(/^\\[object\\s(.*)\\]$/),\n			type = match && match[1] || \"\";\n\n		switch ( type ) {\n			case \"Number\":\n				if ( isNaN(obj) ) {\n					return \"nan\";\n				}\n				return \"number\";\n			case \"String\":\n			case \"Boolean\":\n			case \"Array\":\n			case \"Date\":\n			case \"RegExp\":\n			case \"Function\":\n				return type.toLowerCase();\n		}\n		if ( typeof obj === \"object\" ) {\n			return \"object\";\n		}\n		return undefined;\n	},\n\n	push: function( result, actual, expected, message ) {\n		if ( !config.current ) {\n			throw new Error( \"assertion outside test context, was \" + sourceFromStacktrace() );\n		}\n\n		var output, source,\n			details = {\n				module: config.current.module,\n				name: config.current.testName,\n				result: result,\n				message: message,\n				actual: actual,\n				expected: expected\n			};\n\n		message = escapeText( message ) || ( result ? \"okay\" : \"failed\" );\n		message = \"<span class=\'test-message\'>\" + message + \"</span>\";\n		output = message;\n\n		if ( !result ) {\n			expected = escapeText( QUnit.jsDump.parse(expected) );\n			actual = escapeText( QUnit.jsDump.parse(actual) );\n			output += \"<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>\" + expected + \"</pre></td></tr>\";\n\n			if ( actual !== expected ) {\n				output += \"<tr class=\'test-actual\'><th>Result: </th><td><pre>\" + actual + \"</pre></td></tr>\";\n				output += \"<tr class=\'test-diff\'><th>Diff: </th><td><pre>\" + QUnit.diff( expected, actual ) + \"</pre></td></tr>\";\n			}\n\n			source = sourceFromStacktrace();\n\n			if ( source ) {\n				details.source = source;\n				output += \"<tr class=\'test-source\'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n			}\n\n			output += \"</table>\";\n		}\n\n		runLoggingCallbacks( \"log\", QUnit, details );\n\n		config.current.assertions.push({\n			result: !!result,\n			message: output\n		});\n	},\n\n	pushFailure: function( message, source, actual ) {\n		if ( !config.current ) {\n			throw new Error( \"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2) );\n		}\n\n		var output,\n			details = {\n				module: config.current.module,\n				name: config.current.testName,\n				result: false,\n				message: message\n			};\n\n		message = escapeText( message ) || \"error\";\n		message = \"<span class=\'test-message\'>\" + message + \"</span>\";\n		output = message;\n\n		output += \"<table>\";\n\n		if ( actual ) {\n			output += \"<tr class=\'test-actual\'><th>Result: </th><td><pre>\" + escapeText( actual ) + \"</pre></td></tr>\";\n		}\n\n		if ( source ) {\n			details.source = source;\n			output += \"<tr class=\'test-source\'><th>Source: </th><td><pre>\" + escapeText( source ) + \"</pre></td></tr>\";\n		}\n\n		output += \"</table>\";\n\n		runLoggingCallbacks( \"log\", QUnit, details );\n\n		config.current.assertions.push({\n			result: false,\n			message: output\n		});\n	},\n\n	url: function( params ) {\n		params = extend( extend( {}, QUnit.urlParams ), params );\n		var key,\n			querystring = \"?\";\n\n		for ( key in params ) {\n			if ( hasOwn.call( params, key ) ) {\n				querystring += encodeURIComponent( key ) + \"=\" +\n					encodeURIComponent( params[ key ] ) + \"&\";\n			}\n		}\n		return window.location.protocol + \"//\" + window.location.host +\n			window.location.pathname + querystring.slice( 0, -1 );\n	},\n\n	extend: extend,\n	id: id,\n	addEvent: addEvent,\n	addClass: addClass,\n	hasClass: hasClass,\n	removeClass: removeClass\n	// load, equiv, jsDump, diff: Attached later\n});\n\n/**\n * @deprecated: Created for backwards compatibility with test runner that set the hook function\n * into QUnit.{hook}, instead of invoking it and passing the hook function.\n * QUnit.constructor is set to the empty F() above so that we can add to it\'s prototype here.\n * Doing this allows us to tell if the following methods have been overwritten on the actual\n * QUnit object.\n */\nextend( QUnit.constructor.prototype, {\n\n	// Logging callbacks; all receive a single argument with the listed properties\n	// run test/logs.html for any related changes\n	begin: registerLoggingCallback( \"begin\" ),\n\n	// done: { failed, passed, total, runtime }\n	done: registerLoggingCallback( \"done\" ),\n\n	// log: { result, actual, expected, message }\n	log: registerLoggingCallback( \"log\" ),\n\n	// testStart: { name }\n	testStart: registerLoggingCallback( \"testStart\" ),\n\n	// testDone: { name, failed, passed, total, duration }\n	testDone: registerLoggingCallback( \"testDone\" ),\n\n	// moduleStart: { name }\n	moduleStart: registerLoggingCallback( \"moduleStart\" ),\n\n	// moduleDone: { name, failed, passed, total }\n	moduleDone: registerLoggingCallback( \"moduleDone\" )\n});\n\nif ( typeof document === \"undefined\" || document.readyState === \"complete\" ) {\n	config.autorun = true;\n}\n\nQUnit.load = function() {\n	runLoggingCallbacks( \"begin\", QUnit, {} );\n\n	// Initialize the config, saving the execution queue\n	var banner, filter, i, label, len, main, ol, toolbar, userAgent, val,\n		urlConfigCheckboxesContainer, urlConfigCheckboxes, moduleFilter,\n		numModules = 0,\n		moduleNames = [],\n		moduleFilterHtml = \"\",\n		urlConfigHtml = \"\",\n		oldconfig = extend( {}, config );\n\n	QUnit.init();\n	extend(config, oldconfig);\n\n	config.blocking = false;\n\n	len = config.urlConfig.length;\n\n	for ( i = 0; i < len; i++ ) {\n		val = config.urlConfig[i];\n		if ( typeof val === \"string\" ) {\n			val = {\n				id: val,\n				label: val,\n				tooltip: \"[no tooltip available]\"\n			};\n		}\n		config[ val.id ] = QUnit.urlParams[ val.id ];\n		urlConfigHtml += \"<input id=\'qunit-urlconfig-\" + escapeText( val.id ) +\n			\"\' name=\'\" + escapeText( val.id ) +\n			\"\' type=\'checkbox\'\" + ( config[ val.id ] ? \" checked=\'checked\'\" : \"\" ) +\n			\" title=\'\" + escapeText( val.tooltip ) +\n			\"\'><label for=\'qunit-urlconfig-\" + escapeText( val.id ) +\n			\"\' title=\'\" + escapeText( val.tooltip ) + \"\'>\" + val.label + \"</label>\";\n	}\n	for ( i in config.modules ) {\n		if ( config.modules.hasOwnProperty( i ) ) {\n			moduleNames.push(i);\n		}\n	}\n	numModules = moduleNames.length;\n	moduleNames.sort( function( a, b ) {\n		return a.localeCompare( b );\n	});\n	moduleFilterHtml += \"<label for=\'qunit-modulefilter\'>Module: </label><select id=\'qunit-modulefilter\' name=\'modulefilter\'><option value=\'\' \" +\n		( config.module === undefined  ? \"selected=\'selected\'\" : \"\" ) +\n		\">< All Modules ></option>\";\n\n\n	for ( i = 0; i < numModules; i++) {\n			moduleFilterHtml += \"<option value=\'\" + escapeText( encodeURIComponent(moduleNames[i]) ) + \"\' \" +\n				( config.module === moduleNames[i] ? \"selected=\'selected\'\" : \"\" ) +\n				\">\" + escapeText(moduleNames[i]) + \"</option>\";\n	}\n	moduleFilterHtml += \"</select>\";\n\n	// `userAgent` initialized at top of scope\n	userAgent = id( \"qunit-userAgent\" );\n	if ( userAgent ) {\n		userAgent.innerHTML = navigator.userAgent;\n	}\n\n	// `banner` initialized at top of scope\n	banner = id( \"qunit-header\" );\n	if ( banner ) {\n		banner.innerHTML = \"<a href=\'\" + QUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) + \"\'>\" + banner.innerHTML + \"</a> \";\n	}\n\n	// `toolbar` initialized at top of scope\n	toolbar = id( \"qunit-testrunner-toolbar\" );\n	if ( toolbar ) {\n		// `filter` initialized at top of scope\n		filter = document.createElement( \"input\" );\n		filter.type = \"checkbox\";\n		filter.id = \"qunit-filter-pass\";\n\n		addEvent( filter, \"click\", function() {\n			var tmp,\n				ol = document.getElementById( \"qunit-tests\" );\n\n			if ( filter.checked ) {\n				ol.className = ol.className + \" hidepass\";\n			} else {\n				tmp = \" \" + ol.className.replace( /[\\n\\t\\r]/g, \" \" ) + \" \";\n				ol.className = tmp.replace( / hidepass /, \" \" );\n			}\n			if ( defined.sessionStorage ) {\n				if (filter.checked) {\n					sessionStorage.setItem( \"qunit-filter-passed-tests\", \"true\" );\n				} else {\n					sessionStorage.removeItem( \"qunit-filter-passed-tests\" );\n				}\n			}\n		});\n\n		if ( config.hidepassed || defined.sessionStorage && sessionStorage.getItem( \"qunit-filter-passed-tests\" ) ) {\n			filter.checked = true;\n			// `ol` initialized at top of scope\n			ol = document.getElementById( \"qunit-tests\" );\n			ol.className = ol.className + \" hidepass\";\n		}\n		toolbar.appendChild( filter );\n\n		// `label` initialized at top of scope\n		label = document.createElement( \"label\" );\n		label.setAttribute( \"for\", \"qunit-filter-pass\" );\n		label.setAttribute( \"title\", \"Only show tests and assertions that fail. Stored in sessionStorage.\" );\n		label.innerHTML = \"Hide passed tests\";\n		toolbar.appendChild( label );\n\n		urlConfigCheckboxesContainer = document.createElement(\"span\");\n		urlConfigCheckboxesContainer.innerHTML = urlConfigHtml;\n		urlConfigCheckboxes = urlConfigCheckboxesContainer.getElementsByTagName(\"input\");\n		// For oldIE support:\n		// * Add handlers to the individual elements instead of the container\n		// * Use \"click\" instead of \"change\"\n		// * Fallback from event.target to event.srcElement\n		addEvents( urlConfigCheckboxes, \"click\", function( event ) {\n			var params = {},\n				target = event.target || event.srcElement;\n			params[ target.name ] = target.checked ? true : undefined;\n			window.location = QUnit.url( params );\n		});\n		toolbar.appendChild( urlConfigCheckboxesContainer );\n\n		if (numModules > 1) {\n			moduleFilter = document.createElement( \"span\" );\n			moduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n			moduleFilter.innerHTML = moduleFilterHtml;\n			addEvent( moduleFilter.lastChild, \"change\", function() {\n				var selectBox = moduleFilter.getElementsByTagName(\"select\")[0],\n					selectedModule = decodeURIComponent(selectBox.options[selectBox.selectedIndex].value);\n\n				window.location = QUnit.url({\n					module: ( selectedModule === \"\" ) ? undefined : selectedModule,\n					// Remove any existing filters\n					filter: undefined,\n					testNumber: undefined\n				});\n			});\n			toolbar.appendChild(moduleFilter);\n		}\n	}\n\n	// `main` initialized at top of scope\n	main = id( \"qunit-fixture\" );\n	if ( main ) {\n		config.fixture = main.innerHTML;\n	}\n\n	if ( config.autostart ) {\n		QUnit.start();\n	}\n};\n\naddEvent( window, \"load\", QUnit.load );\n\n// `onErrorFnPrev` initialized at top of scope\n// Preserve other handlers\nonErrorFnPrev = window.onerror;\n\n// Cover uncaught exceptions\n// Returning true will suppress the default browser handler,\n// returning false will let it run.\nwindow.onerror = function ( error, filePath, linerNr ) {\n	var ret = false;\n	if ( onErrorFnPrev ) {\n		ret = onErrorFnPrev( error, filePath, linerNr );\n	}\n\n	// Treat return value as window.onerror itself does,\n	// Only do our handling if not suppressed.\n	if ( ret !== true ) {\n		if ( QUnit.config.current ) {\n			if ( QUnit.config.current.ignoreGlobalErrors ) {\n				return true;\n			}\n			QUnit.pushFailure( error, filePath + \":\" + linerNr );\n		} else {\n			QUnit.test( \"global failure\", extend( function() {\n				QUnit.pushFailure( error, filePath + \":\" + linerNr );\n			}, { validTest: validTest } ) );\n		}\n		return false;\n	}\n\n	return ret;\n};\n\nfunction done() {\n	config.autorun = true;\n\n	// Log the last module results\n	if ( config.currentModule ) {\n		runLoggingCallbacks( \"moduleDone\", QUnit, {\n			name: config.currentModule,\n			failed: config.moduleStats.bad,\n			passed: config.moduleStats.all - config.moduleStats.bad,\n			total: config.moduleStats.all\n		});\n	}\n	delete config.previousModule;\n\n	var i, key,\n		banner = id( \"qunit-banner\" ),\n		tests = id( \"qunit-tests\" ),\n		runtime = +new Date() - config.started,\n		passed = config.stats.all - config.stats.bad,\n		html = [\n			\"Tests completed in \",\n			runtime,\n			\" milliseconds.<br/>\",\n			\"<span class=\'passed\'>\",\n			passed,\n			\"</span> assertions of <span class=\'total\'>\",\n			config.stats.all,\n			\"</span> passed, <span class=\'failed\'>\",\n			config.stats.bad,\n			\"</span> failed.\"\n		].join( \"\" );\n\n	if ( banner ) {\n		banner.className = ( config.stats.bad ? \"qunit-fail\" : \"qunit-pass\" );\n	}\n\n	if ( tests ) {\n		id( \"qunit-testresult\" ).innerHTML = html;\n	}\n\n	if ( config.altertitle && typeof document !== \"undefined\" && document.title ) {\n		// show ✖ for good, ✔ for bad suite result in title\n		// use escape sequences in case file gets loaded with non-utf-8-charset\n		document.title = [\n			( config.stats.bad ? \"\\u2716\" : \"\\u2714\" ),\n			document.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n		].join( \" \" );\n	}\n\n	// clear own sessionStorage items if all tests passed\n	if ( config.reorder && defined.sessionStorage && config.stats.bad === 0 ) {\n		// `key` & `i` initialized at top of scope\n		for ( i = 0; i < sessionStorage.length; i++ ) {\n			key = sessionStorage.key( i++ );\n			if ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n				sessionStorage.removeItem( key );\n			}\n		}\n	}\n\n	// scroll back to top to show results\n	if ( window.scrollTo ) {\n		window.scrollTo(0, 0);\n	}\n\n	runLoggingCallbacks( \"done\", QUnit, {\n		failed: config.stats.bad,\n		passed: passed,\n		total: config.stats.all,\n		runtime: runtime\n	});\n}\n\n/** @return Boolean: true if this test should be ran */\nfunction validTest( test ) {\n	var include,\n		filter = config.filter && config.filter.toLowerCase(),\n		module = config.module && config.module.toLowerCase(),\n		fullName = (test.module + \": \" + test.testName).toLowerCase();\n\n	// Internally-generated tests are always valid\n	if ( test.callback && test.callback.validTest === validTest ) {\n		delete test.callback.validTest;\n		return true;\n	}\n\n	if ( config.testNumber ) {\n		return test.testNumber === config.testNumber;\n	}\n\n	if ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {\n		return false;\n	}\n\n	if ( !filter ) {\n		return true;\n	}\n\n	include = filter.charAt( 0 ) !== \"!\";\n	if ( !include ) {\n		filter = filter.slice( 1 );\n	}\n\n	// If the filter matches, we need to honour include\n	if ( fullName.indexOf( filter ) !== -1 ) {\n		return include;\n	}\n\n	// Otherwise, do the opposite\n	return !include;\n}\n\n// so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)\n// Later Safari and IE10 are supposed to support error.stack as well\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n	offset = offset === undefined ? 3 : offset;\n\n	var stack, include, i;\n\n	if ( e.stacktrace ) {\n		// Opera\n		return e.stacktrace.split( \"\\n\" )[ offset + 3 ];\n	} else if ( e.stack ) {\n		// Firefox, Chrome\n		stack = e.stack.split( \"\\n\" );\n		if (/^error$/i.test( stack[0] ) ) {\n			stack.shift();\n		}\n		if ( fileName ) {\n			include = [];\n			for ( i = offset; i < stack.length; i++ ) {\n				if ( stack[ i ].indexOf( fileName ) !== -1 ) {\n					break;\n				}\n				include.push( stack[ i ] );\n			}\n			if ( include.length ) {\n				return include.join( \"\\n\" );\n			}\n		}\n		return stack[ offset ];\n	} else if ( e.sourceURL ) {\n		// Safari, PhantomJS\n		// hopefully one day Safari provides actual stacktraces\n		// exclude useless self-reference for generated Error objects\n		if ( /qunit.js$/.test( e.sourceURL ) ) {\n			return;\n		}\n		// for actual exceptions, this is useful\n		return e.sourceURL + \":\" + e.line;\n	}\n}\nfunction sourceFromStacktrace( offset ) {\n	try {\n		throw new Error();\n	} catch ( e ) {\n		return extractStacktrace( e, offset );\n	}\n}\n\n/**\n * Escape text for attribute or text content.\n */\nfunction escapeText( s ) {\n	if ( !s ) {\n		return \"\";\n	}\n	s = s + \"\";\n	// Both single quotes and double quotes (for attributes)\n	return s.replace( /[\'\"<>&]/g, function( s ) {\n		switch( s ) {\n			case \"\'\":\n				return \"&#039;\";\n			case \"\\\"\":\n				return \"&quot;\";\n			case \"<\":\n				return \"&lt;\";\n			case \">\":\n				return \"&gt;\";\n			case \"&\":\n				return \"&amp;\";\n		}\n	});\n}\n\nfunction synchronize( callback, last ) {\n	config.queue.push( callback );\n\n	if ( config.autorun && !config.blocking ) {\n		process( last );\n	}\n}\n\nfunction process( last ) {\n	function next() {\n		process( last );\n	}\n	var start = new Date().getTime();\n	config.depth = config.depth ? config.depth + 1 : 1;\n\n	while ( config.queue.length && !config.blocking ) {\n		if ( !defined.setTimeout || config.updateRate <= 0 || ( ( new Date().getTime() - start ) < config.updateRate ) ) {\n			config.queue.shift()();\n		} else {\n			setTimeout( next, 13 );\n			break;\n		}\n	}\n	config.depth--;\n	if ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n		done();\n	}\n}\n\nfunction saveGlobal() {\n	config.pollution = [];\n\n	if ( config.noglobals ) {\n		for ( var key in window ) {\n			if ( hasOwn.call( window, key ) ) {\n				// in Opera sometimes DOM element ids show up here, ignore them\n				if ( /^qunit-test-output/.test( key ) ) {\n					continue;\n				}\n				config.pollution.push( key );\n			}\n		}\n	}\n}\n\nfunction checkPollution() {\n	var newGlobals,\n		deletedGlobals,\n		old = config.pollution;\n\n	saveGlobal();\n\n	newGlobals = diff( config.pollution, old );\n	if ( newGlobals.length > 0 ) {\n		QUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join(\", \") );\n	}\n\n	deletedGlobals = diff( old, config.pollution );\n	if ( deletedGlobals.length > 0 ) {\n		QUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join(\", \") );\n	}\n}\n\n// returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n	var i, j,\n		result = a.slice();\n\n	for ( i = 0; i < result.length; i++ ) {\n		for ( j = 0; j < b.length; j++ ) {\n			if ( result[i] === b[j] ) {\n				result.splice( i, 1 );\n				i--;\n				break;\n			}\n		}\n	}\n	return result;\n}\n\nfunction extend( a, b ) {\n	for ( var prop in b ) {\n		if ( hasOwn.call( b, prop ) ) {\n			// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n			if ( !( prop === \"constructor\" && a === window ) ) {\n				if ( b[ prop ] === undefined ) {\n					delete a[ prop ];\n				} else {\n					a[ prop ] = b[ prop ];\n				}\n			}\n		}\n	}\n\n	return a;\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n	// Standards-based browsers\n	if ( elem.addEventListener ) {\n		elem.addEventListener( type, fn, false );\n	// IE\n	} else {\n		elem.attachEvent( \"on\" + type, fn );\n	}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n	var i = elems.length;\n	while ( i-- ) {\n		addEvent( elems[i], type, fn );\n	}\n}\n\nfunction hasClass( elem, name ) {\n	return (\" \" + elem.className + \" \").indexOf(\" \" + name + \" \") > -1;\n}\n\nfunction addClass( elem, name ) {\n	if ( !hasClass( elem, name ) ) {\n		elem.className += (elem.className ? \" \" : \"\") + name;\n	}\n}\n\nfunction removeClass( elem, name ) {\n	var set = \" \" + elem.className + \" \";\n	// Class name may appear multiple times\n	while ( set.indexOf(\" \" + name + \" \") > -1 ) {\n		set = set.replace(\" \" + name + \" \" , \" \");\n	}\n	// If possible, trim it for prettiness, but not necessarily\n	elem.className = typeof set.trim === \"function\" ? set.trim() : set.replace(/^\\s+|\\s+$/g, \"\");\n}\n\nfunction id( name ) {\n	return !!( typeof document !== \"undefined\" && document && document.getElementById ) &&\n		document.getElementById( name );\n}\n\nfunction registerLoggingCallback( key ) {\n	return function( callback ) {\n		config[key].push( callback );\n	};\n}\n\n// Supports deprecated method of completely overwriting logging callbacks\nfunction runLoggingCallbacks( key, scope, args ) {\n	var i, callbacks;\n	if ( QUnit.hasOwnProperty( key ) ) {\n		QUnit[ key ].call(scope, args );\n	} else {\n		callbacks = config[ key ];\n		for ( i = 0; i < callbacks.length; i++ ) {\n			callbacks[ i ].call( scope, args );\n		}\n	}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = (function() {\n\n	// Call the o related callback with the given arguments.\n	function bindCallbacks( o, callbacks, args ) {\n		var prop = QUnit.objectType( o );\n		if ( prop ) {\n			if ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\n				return callbacks[ prop ].apply( callbacks, args );\n			} else {\n				return callbacks[ prop ]; // or undefined\n			}\n		}\n	}\n\n	// the real equiv function\n	var innerEquiv,\n		// stack to decide between skip/abort functions\n		callers = [],\n		// stack to avoiding loops from circular referencing\n		parents = [],\n		parentsB = [],\n\n		getProto = Object.getPrototypeOf || function ( obj ) {\n			/*jshint camelcase:false */\n			return obj.__proto__;\n		},\n		callbacks = (function () {\n\n			// for string, boolean, number and null\n			function useStrictEquality( b, a ) {\n				/*jshint eqeqeq:false */\n				if ( b instanceof a.constructor || a instanceof b.constructor ) {\n					// to catch short annotation VS \'new\' annotation of a\n					// declaration\n					// e.g. var i = 1;\n					// var j = new Number(1);\n					return a == b;\n				} else {\n					return a === b;\n				}\n			}\n\n			return {\n				\"string\": useStrictEquality,\n				\"boolean\": useStrictEquality,\n				\"number\": useStrictEquality,\n				\"null\": useStrictEquality,\n				\"undefined\": useStrictEquality,\n\n				\"nan\": function( b ) {\n					return isNaN( b );\n				},\n\n				\"date\": function( b, a ) {\n					return QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n				},\n\n				\"regexp\": function( b, a ) {\n					return QUnit.objectType( b ) === \"regexp\" &&\n						// the regex itself\n						a.source === b.source &&\n						// and its modifiers\n						a.global === b.global &&\n						// (gmi) ...\n						a.ignoreCase === b.ignoreCase &&\n						a.multiline === b.multiline &&\n						a.sticky === b.sticky;\n				},\n\n				// - skip when the property is a method of an instance (OOP)\n				// - abort otherwise,\n				// initial === would have catch identical references anyway\n				\"function\": function() {\n					var caller = callers[callers.length - 1];\n					return caller !== Object && typeof caller !== \"undefined\";\n				},\n\n				\"array\": function( b, a ) {\n					var i, j, len, loop, aCircular, bCircular;\n\n					// b could be an object literal here\n					if ( QUnit.objectType( b ) !== \"array\" ) {\n						return false;\n					}\n\n					len = a.length;\n					if ( len !== b.length ) {\n						// safe and faster\n						return false;\n					}\n\n					// track reference to avoid circular references\n					parents.push( a );\n					parentsB.push( b );\n					for ( i = 0; i < len; i++ ) {\n						loop = false;\n						for ( j = 0; j < parents.length; j++ ) {\n							aCircular = parents[j] === a[i];\n							bCircular = parentsB[j] === b[i];\n							if ( aCircular || bCircular ) {\n								if ( a[i] === b[i] || aCircular && bCircular ) {\n									loop = true;\n								} else {\n									parents.pop();\n									parentsB.pop();\n									return false;\n								}\n							}\n						}\n						if ( !loop && !innerEquiv(a[i], b[i]) ) {\n							parents.pop();\n							parentsB.pop();\n							return false;\n						}\n					}\n					parents.pop();\n					parentsB.pop();\n					return true;\n				},\n\n				\"object\": function( b, a ) {\n					/*jshint forin:false */\n					var i, j, loop, aCircular, bCircular,\n						// Default to true\n						eq = true,\n						aProperties = [],\n						bProperties = [];\n\n					// comparing constructors is more strict than using\n					// instanceof\n					if ( a.constructor !== b.constructor ) {\n						// Allow objects with no prototype to be equivalent to\n						// objects with Object as their constructor.\n						if ( !(( getProto(a) === null && getProto(b) === Object.prototype ) ||\n							( getProto(b) === null && getProto(a) === Object.prototype ) ) ) {\n								return false;\n						}\n					}\n\n					// stack constructor before traversing properties\n					callers.push( a.constructor );\n\n					// track reference to avoid circular references\n					parents.push( a );\n					parentsB.push( b );\n\n					// be strict: don\'t ensure hasOwnProperty and go deep\n					for ( i in a ) {\n						loop = false;\n						for ( j = 0; j < parents.length; j++ ) {\n							aCircular = parents[j] === a[i];\n							bCircular = parentsB[j] === b[i];\n							if ( aCircular || bCircular ) {\n								if ( a[i] === b[i] || aCircular && bCircular ) {\n									loop = true;\n								} else {\n									eq = false;\n									break;\n								}\n							}\n						}\n						aProperties.push(i);\n						if ( !loop && !innerEquiv(a[i], b[i]) ) {\n							eq = false;\n							break;\n						}\n					}\n\n					parents.pop();\n					parentsB.pop();\n					callers.pop(); // unstack, we are done\n\n					for ( i in b ) {\n						bProperties.push( i ); // collect b\'s properties\n					}\n\n					// Ensures identical properties name\n					return eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n				}\n			};\n		}());\n\n	innerEquiv = function() { // can take multiple arguments\n		var args = [].slice.apply( arguments );\n		if ( args.length < 2 ) {\n			return true; // end transition\n		}\n\n		return (function( a, b ) {\n			if ( a === b ) {\n				return true; // catch the most you can\n			} else if ( a === null || b === null || typeof a === \"undefined\" ||\n					typeof b === \"undefined\" ||\n					QUnit.objectType(a) !== QUnit.objectType(b) ) {\n				return false; // don\'t lose time with error prone cases\n			} else {\n				return bindCallbacks(a, callbacks, [ b, a ]);\n			}\n\n			// apply transition with (1..n) arguments\n		}( args[0], args[1] ) && innerEquiv.apply( this, args.splice(1, args.length - 1 )) );\n	};\n\n	return innerEquiv;\n}());\n\n/**\n * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |\n * http://flesler.blogspot.com Licensed under BSD\n * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008\n *\n * @projectDescription Advanced and extensible data dumping for Javascript.\n * @version 1.0.0\n * @author Ariel Flesler\n * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}\n */\nQUnit.jsDump = (function() {\n	function quote( str ) {\n		return \"\\\"\" + str.toString().replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n	}\n	function literal( o ) {\n		return o + \"\";\n	}\n	function join( pre, arr, post ) {\n		var s = jsDump.separator(),\n			base = jsDump.indent(),\n			inner = jsDump.indent(1);\n		if ( arr.join ) {\n			arr = arr.join( \",\" + s + inner );\n		}\n		if ( !arr ) {\n			return pre + post;\n		}\n		return [ pre, inner + arr, base + post ].join(s);\n	}\n	function array( arr, stack ) {\n		var i = arr.length, ret = new Array(i);\n		this.up();\n		while ( i-- ) {\n			ret[i] = this.parse( arr[i] , undefined , stack);\n		}\n		this.down();\n		return join( \"[\", ret, \"]\" );\n	}\n\n	var reName = /^function (\\w+)/,\n		jsDump = {\n			// type is used mostly internally, you can fix a (custom)type in advance\n			parse: function( obj, type, stack ) {\n				stack = stack || [ ];\n				var inStack, res,\n					parser = this.parsers[ type || this.typeOf(obj) ];\n\n				type = typeof parser;\n				inStack = inArray( obj, stack );\n\n				if ( inStack !== -1 ) {\n					return \"recursion(\" + (inStack - stack.length) + \")\";\n				}\n				if ( type === \"function\" )  {\n					stack.push( obj );\n					res = parser.call( this, obj, stack );\n					stack.pop();\n					return res;\n				}\n				return ( type === \"string\" ) ? parser : this.parsers.error;\n			},\n			typeOf: function( obj ) {\n				var type;\n				if ( obj === null ) {\n					type = \"null\";\n				} else if ( typeof obj === \"undefined\" ) {\n					type = \"undefined\";\n				} else if ( QUnit.is( \"regexp\", obj) ) {\n					type = \"regexp\";\n				} else if ( QUnit.is( \"date\", obj) ) {\n					type = \"date\";\n				} else if ( QUnit.is( \"function\", obj) ) {\n					type = \"function\";\n				} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== \"undefined\" && typeof obj.nodeType === \"undefined\" ) {\n					type = \"window\";\n				} else if ( obj.nodeType === 9 ) {\n					type = \"document\";\n				} else if ( obj.nodeType ) {\n					type = \"node\";\n				} else if (\n					// native arrays\n					toString.call( obj ) === \"[object Array]\" ||\n					// NodeList objects\n					( typeof obj.length === \"number\" && typeof obj.item !== \"undefined\" && ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null && typeof obj[0] === \"undefined\" ) ) )\n				) {\n					type = \"array\";\n				} else if ( obj.constructor === Error.prototype.constructor ) {\n					type = \"error\";\n				} else {\n					type = typeof obj;\n				}\n				return type;\n			},\n			separator: function() {\n				return this.multiline ?	this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&nbsp;\" : \" \";\n			},\n			// extra can be a number, shortcut for increasing-calling-decreasing\n			indent: function( extra ) {\n				if ( !this.multiline ) {\n					return \"\";\n				}\n				var chr = this.indentChar;\n				if ( this.HTML ) {\n					chr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&nbsp;\" );\n				}\n				return new Array( this.depth + ( extra || 0 ) ).join(chr);\n			},\n			up: function( a ) {\n				this.depth += a || 1;\n			},\n			down: function( a ) {\n				this.depth -= a || 1;\n			},\n			setParser: function( name, parser ) {\n				this.parsers[name] = parser;\n			},\n			// The next 3 are exposed so you can use them\n			quote: quote,\n			literal: literal,\n			join: join,\n			//\n			depth: 1,\n			// This is the list of parsers, to modify them, use jsDump.setParser\n			parsers: {\n				window: \"[Window]\",\n				document: \"[Document]\",\n				error: function(error) {\n					return \"Error(\\\"\" + error.message + \"\\\")\";\n				},\n				unknown: \"[Unknown]\",\n				\"null\": \"null\",\n				\"undefined\": \"undefined\",\n				\"function\": function( fn ) {\n					var ret = \"function\",\n						// functions never have name in IE\n						name = \"name\" in fn ? fn.name : (reName.exec(fn) || [])[1];\n\n					if ( name ) {\n						ret += \" \" + name;\n					}\n					ret += \"( \";\n\n					ret = [ ret, QUnit.jsDump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n					return join( ret, QUnit.jsDump.parse(fn,\"functionCode\" ), \"}\" );\n				},\n				array: array,\n				nodelist: array,\n				\"arguments\": array,\n				object: function( map, stack ) {\n					/*jshint forin:false */\n					var ret = [ ], keys, key, val, i;\n					QUnit.jsDump.up();\n					keys = [];\n					for ( key in map ) {\n						keys.push( key );\n					}\n					keys.sort();\n					for ( i = 0; i < keys.length; i++ ) {\n						key = keys[ i ];\n						val = map[ key ];\n						ret.push( QUnit.jsDump.parse( key, \"key\" ) + \": \" + QUnit.jsDump.parse( val, undefined, stack ) );\n					}\n					QUnit.jsDump.down();\n					return join( \"{\", ret, \"}\" );\n				},\n				node: function( node ) {\n					var len, i, val,\n						open = QUnit.jsDump.HTML ? \"&lt;\" : \"<\",\n						close = QUnit.jsDump.HTML ? \"&gt;\" : \">\",\n						tag = node.nodeName.toLowerCase(),\n						ret = open + tag,\n						attrs = node.attributes;\n\n					if ( attrs ) {\n						for ( i = 0, len = attrs.length; i < len; i++ ) {\n							val = attrs[i].nodeValue;\n							// IE6 includes all attributes in .attributes, even ones not explicitly set.\n							// Those have values like undefined, null, 0, false, \"\" or \"inherit\".\n							if ( val && val !== \"inherit\" ) {\n								ret += \" \" + attrs[i].nodeName + \"=\" + QUnit.jsDump.parse( val, \"attribute\" );\n							}\n						}\n					}\n					ret += close;\n\n					// Show content of TextNode or CDATASection\n					if ( node.nodeType === 3 || node.nodeType === 4 ) {\n						ret += node.nodeValue;\n					}\n\n					return ret + open + \"/\" + tag + close;\n				},\n				// function calls it internally, it\'s the arguments part of the function\n				functionArgs: function( fn ) {\n					var args,\n						l = fn.length;\n\n					if ( !l ) {\n						return \"\";\n					}\n\n					args = new Array(l);\n					while ( l-- ) {\n						// 97 is \'a\'\n						args[l] = String.fromCharCode(97+l);\n					}\n					return \" \" + args.join( \", \" ) + \" \";\n				},\n				// object calls it internally, the key part of an item in a map\n				key: quote,\n				// function calls it internally, it\'s the content of the function\n				functionCode: \"[code]\",\n				// node calls it internally, it\'s an html attribute value\n				attribute: quote,\n				string: quote,\n				date: quote,\n				regexp: literal,\n				number: literal,\n				\"boolean\": literal\n			},\n			// if true, entities are escaped ( <, >, \\t, space and \\n )\n			HTML: false,\n			// indentation unit\n			indentChar: \"  \",\n			// if true, items in a collection, are separated by a \\n, else just a space.\n			multiline: true\n		};\n\n	return jsDump;\n}());\n\n// from jquery.js\nfunction inArray( elem, array ) {\n	if ( array.indexOf ) {\n		return array.indexOf( elem );\n	}\n\n	for ( var i = 0, length = array.length; i < length; i++ ) {\n		if ( array[ i ] === elem ) {\n			return i;\n		}\n	}\n\n	return -1;\n}\n\n/*\n * Javascript Diff Algorithm\n *  By John Resig (http://ejohn.org/)\n *  Modified by Chu Alan \"sprite\"\n *\n * Released under the MIT license.\n *\n * More Info:\n *  http://ejohn.org/projects/javascript-diff-algorithm/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\"\n */\nQUnit.diff = (function() {\n	/*jshint eqeqeq:false, eqnull:true */\n	function diff( o, n ) {\n		var i,\n			ns = {},\n			os = {};\n\n		for ( i = 0; i < n.length; i++ ) {\n			if ( !hasOwn.call( ns, n[i] ) ) {\n				ns[ n[i] ] = {\n					rows: [],\n					o: null\n				};\n			}\n			ns[ n[i] ].rows.push( i );\n		}\n\n		for ( i = 0; i < o.length; i++ ) {\n			if ( !hasOwn.call( os, o[i] ) ) {\n				os[ o[i] ] = {\n					rows: [],\n					n: null\n				};\n			}\n			os[ o[i] ].rows.push( i );\n		}\n\n		for ( i in ns ) {\n			if ( hasOwn.call( ns, i ) ) {\n				if ( ns[i].rows.length === 1 && hasOwn.call( os, i ) && os[i].rows.length === 1 ) {\n					n[ ns[i].rows[0] ] = {\n						text: n[ ns[i].rows[0] ],\n						row: os[i].rows[0]\n					};\n					o[ os[i].rows[0] ] = {\n						text: o[ os[i].rows[0] ],\n						row: ns[i].rows[0]\n					};\n				}\n			}\n		}\n\n		for ( i = 0; i < n.length - 1; i++ ) {\n			if ( n[i].text != null && n[ i + 1 ].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null &&\n						n[ i + 1 ] == o[ n[i].row + 1 ] ) {\n\n				n[ i + 1 ] = {\n					text: n[ i + 1 ],\n					row: n[i].row + 1\n				};\n				o[ n[i].row + 1 ] = {\n					text: o[ n[i].row + 1 ],\n					row: i + 1\n				};\n			}\n		}\n\n		for ( i = n.length - 1; i > 0; i-- ) {\n			if ( n[i].text != null && n[ i - 1 ].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null &&\n						n[ i - 1 ] == o[ n[i].row - 1 ]) {\n\n				n[ i - 1 ] = {\n					text: n[ i - 1 ],\n					row: n[i].row - 1\n				};\n				o[ n[i].row - 1 ] = {\n					text: o[ n[i].row - 1 ],\n					row: i - 1\n				};\n			}\n		}\n\n		return {\n			o: o,\n			n: n\n		};\n	}\n\n	return function( o, n ) {\n		o = o.replace( /\\s+$/, \"\" );\n		n = n.replace( /\\s+$/, \"\" );\n\n		var i, pre,\n			str = \"\",\n			out = diff( o === \"\" ? [] : o.split(/\\s+/), n === \"\" ? [] : n.split(/\\s+/) ),\n			oSpace = o.match(/\\s+/g),\n			nSpace = n.match(/\\s+/g);\n\n		if ( oSpace == null ) {\n			oSpace = [ \" \" ];\n		}\n		else {\n			oSpace.push( \" \" );\n		}\n\n		if ( nSpace == null ) {\n			nSpace = [ \" \" ];\n		}\n		else {\n			nSpace.push( \" \" );\n		}\n\n		if ( out.n.length === 0 ) {\n			for ( i = 0; i < out.o.length; i++ ) {\n				str += \"<del>\" + out.o[i] + oSpace[i] + \"</del>\";\n			}\n		}\n		else {\n			if ( out.n[0].text == null ) {\n				for ( n = 0; n < out.o.length && out.o[n].text == null; n++ ) {\n					str += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n				}\n			}\n\n			for ( i = 0; i < out.n.length; i++ ) {\n				if (out.n[i].text == null) {\n					str += \"<ins>\" + out.n[i] + nSpace[i] + \"</ins>\";\n				}\n				else {\n					// `pre` initialized at top of scope\n					pre = \"\";\n\n					for ( n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {\n						pre += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\n					}\n					str += \" \" + out.n[i].text + nSpace[i] + pre;\n				}\n			}\n		}\n\n		return str;\n	};\n}());\n\n// for CommonJS environments, export everything\nif ( typeof exports !== \"undefined\" ) {\n	extend( exports, QUnit.constructor.prototype );\n}\n\n// get at whatever the global object is, like window in browsers\n}( (function() {return this;}.call()) ));\n//# sourceURL=qunit/qunit/qunit.js");
eval("/* global define, QUnit */\ndefine(\'qunit\', [], function() {\n  \"use strict\";\n\n  return {\n    \'default\': QUnit\n  };\n});//# sourceURL=test-shims.js");
eval("define(\"ember-qunit/isolated-container\",\n  [\"./test-resolver\",\"ember\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var testResolver = __dependency1__[\"default\"] || __dependency1__;\n    var Ember = __dependency2__[\"default\"] || __dependency2__;\n\n    __exports__[\"default\"] = function isolatedContainer(fullNames) {\n      var resolver = testResolver.get();\n      var container = new Ember.Container();\n      container.optionsForType(\'component\', { singleton: false });\n      container.optionsForType(\'view\', { singleton: false });\n      container.optionsForType(\'template\', { instantiate: false });\n      container.optionsForType(\'helper\', { instantiate: false });\n      container.register(\'component-lookup:main\', Ember.ComponentLookup);\n      for (var i = fullNames.length; i > 0; i--) {\n        var fullName = fullNames[i - 1];\n        container.register(fullName, resolver.resolve(fullName));\n      }\n      return container;\n    }\n  });define(\"ember-qunit\",\n  [\"ember\",\"./isolated-container\",\"./module-for\",\"./module-for-component\",\"./module-for-model\",\"./test\",\"./test-resolver\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {\n    \"use strict\";\n    var Ember = __dependency1__[\"default\"] || __dependency1__;\n    var isolatedContainer = __dependency2__[\"default\"] || __dependency2__;\n    var moduleFor = __dependency3__[\"default\"] || __dependency3__;\n    var moduleForComponent = __dependency4__[\"default\"] || __dependency4__;\n    var moduleForModel = __dependency5__[\"default\"] || __dependency5__;\n    var test = __dependency6__[\"default\"] || __dependency6__;\n    var testResolver = __dependency7__[\"default\"] || __dependency7__;\n\n    Ember.testing = true;\n\n    function setResolver(resolver) {\n      testResolver.set(resolver);\n    }\n\n    function globalize() {\n      window.moduleFor = moduleFor;\n      window.moduleForComponent = moduleForComponent;\n      window.moduleForModel = moduleForModel;\n      window.test = test;\n      window.setResolver = setResolver;\n    }\n\n    __exports__.globalize = globalize;\n    __exports__.moduleFor = moduleFor;\n    __exports__.moduleForComponent = moduleForComponent;\n    __exports__.moduleForModel = moduleForModel;\n    __exports__.test = test;\n    __exports__.setResolver = setResolver;\n  });define(\"ember-qunit/module-for-component\",\n  [\"./test-resolver\",\"./module-for\",\"ember\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {\n    \"use strict\";\n    var testResolver = __dependency1__[\"default\"] || __dependency1__;\n    var moduleFor = __dependency2__[\"default\"] || __dependency2__;\n    var Ember = __dependency3__[\"default\"] || __dependency3__;\n\n    __exports__[\"default\"] = function moduleForComponent(name, description, callbacks) {\n      var resolver = testResolver.get();\n\n      moduleFor(\'component:\' + name, description, callbacks, function(container, context, defaultSubject) {\n        var layoutName = \'template:components/\' + name;\n\n        var layout = resolver.resolve(layoutName);\n\n        if (layout) {\n          container.register(layoutName, layout);\n          container.injection(\'component:\' + name, \'layout\', layoutName);\n        }\n\n        context.dispatcher = Ember.EventDispatcher.create();\n        context.dispatcher.setup({}, \'#ember-testing\');\n\n        context.__setup_properties__.append = function(selector) {\n          var containerView = Ember.ContainerView.create({container: container});\n          var view = Ember.run(function(){\n            var subject = context.subject();\n            containerView.pushObject(subject);\n            // TODO: destory this somewhere\n            containerView.appendTo(\'#ember-testing\');\n            return subject;\n          });\n\n          return view.$();\n        };\n        context.__setup_properties__.$ = context.__setup_properties__.append;\n      });\n    }\n  });define(\"ember-qunit/module-for-model\",\n  [\"./module-for\",\"ember\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var moduleFor = __dependency1__[\"default\"] || __dependency1__;\n    var Ember = __dependency2__[\"default\"] || __dependency2__;\n\n    __exports__[\"default\"] = function moduleForModel(name, description, callbacks) {\n      moduleFor(\'model:\' + name, description, callbacks, function(container, context, defaultSubject) {\n        if (DS._setupContainer) {\n          DS._setupContainer(container);\n        } else {\n          container.register(\'store:main\', DS.Store);\n        }\n\n        var adapterFactory = container.lookupFactory(\'adapter:application\');\n        if (!adapterFactory) {\n          container.register(\'adapter:application\', DS.FixtureAdapter);\n        }\n\n        context.__setup_properties__.store = function(){\n          return container.lookup(\'store:main\');\n        };\n\n        if (context.__setup_properties__.subject === defaultSubject) {\n          context.__setup_properties__.subject = function(options) {\n            return Ember.run(function() {\n              return container.lookup(\'store:main\').createRecord(name, options);\n            });\n          };\n        }\n      });\n    }\n  });define(\"ember-qunit/module-for\",\n  [\"ember\",\"./test-context\",\"./isolated-container\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {\n    \"use strict\";\n    var Ember = __dependency1__[\"default\"] || __dependency1__;\n    //import QUnit from \'qunit\'; // Assumed global in runner\n    var testContext = __dependency2__[\"default\"] || __dependency2__;\n    var isolatedContainer = __dependency3__[\"default\"] || __dependency3__;\n\n    __exports__[\"default\"] = function moduleFor(fullName, description, callbacks, delegate) {\n      var container;\n      var context;\n      \n      var _callbacks = {\n        setup: function(){\n          callbacks = callbacks || { };\n\n          var needs = [fullName].concat(callbacks.needs || []);\n          container = isolatedContainer(needs);\n\n          callbacks.subject   = callbacks.subject || defaultSubject;\n\n          callbacks.setup     = callbacks.setup    || function() { };\n          callbacks.teardown  = callbacks.teardown || function() { };\n          \n          function factory() {\n            return container.lookupFactory(fullName);\n          }\n          \n          testContext.set({\n            container:            container,\n            factory:              factory,\n            dispatcher:           null,\n            __setup_properties__: callbacks\n          });\n          \n          context = testContext.get();\n\n          if (delegate) {\n            delegate(container, context, defaultSubject);\n          }\n          \n          if (Ember.$(\'#ember-testing\').length === 0) {\n            Ember.$(\'<div id=\"ember-testing\"/>\').appendTo(document.body);\n          }\n          \n          buildContextVariables(context);\n          callbacks.setup.call(context, container);\n        },\n\n        teardown: function(){\n          Ember.run(function(){\n            container.destroy();\n            \n            if (context.dispatcher) {\n              context.dispatcher.destroy();\n            }\n          });\n          \n          callbacks.teardown(container);\n          Ember.$(\'#ember-testing\').empty();\n        }\n      };\n\n      QUnit.module(description || fullName, _callbacks);\n    }\n\n    function defaultSubject(options, factory) {\n      return factory.create(options);\n    }\n\n    // allow arbitrary named factories, like rspec let\n    function buildContextVariables(context) {\n      var cache     = { };\n      var callbacks = context.__setup_properties__;\n      var container = context.container;\n      var factory   = context.factory;\n        \n      Ember.keys(callbacks).filter(function(key){\n        // ignore the default setup/teardown keys\n        return key !== \'setup\' && key !== \'teardown\';\n      }).forEach(function(key){\n        context[key] = function(options) {\n          if (cache[key]) { return cache[key]; }\n\n          var result = callbacks[key](options, factory(), container);\n          cache[key] = result;\n          return result;\n        };\n      });\n    }\n  });define(\"ember-qunit/test-context\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var __test_context__;\n\n    function set(context) {\n      __test_context__ = context;\n    }\n\n    __exports__.set = set;function get() {\n      return __test_context__;\n    }\n\n    __exports__.get = get;\n  });define(\"ember-qunit/test-resolver\",\n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var __resolver__;\n\n    function set(resolver) {\n      __resolver__ = resolver;\n    }\n\n    __exports__.set = set;function get() {\n      if (__resolver__ == null) throw new Error(\'you must set a resolver with `testResolver.set(resolver)`\');\n      return __resolver__;\n    }\n\n    __exports__.get = get;\n  });define(\"ember-qunit/test\",\n  [\"ember\",\"./test-context\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var Ember = __dependency1__[\"default\"] || __dependency1__;\n    //import QUnit from \'qunit\'; // Assumed global in runner\n    var testContext = __dependency2__[\"default\"] || __dependency2__;\n\n    function resetViews() {\n      Ember.View.views = {};\n    }\n\n    __exports__[\"default\"] = function test(testName, callback) {\n\n      function wrapper() {\n        var context = testContext.get();\n        \n        resetViews();\n        var result = callback.call(context);\n\n        function failTestOnPromiseRejection(reason) {\n          ok(false, reason);\n        }\n\n        Ember.run(function(){\n          stop();\n          Ember.RSVP.Promise.cast(result)[\'catch\'](failTestOnPromiseRejection)[\'finally\'](start);\n        });\n      }\n\n      QUnit.test(testName, wrapper);\n    }\n  });//# sourceURL=ember-qunit/dist/named-amd/main.js");
